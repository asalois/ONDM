%%%% This function calculates Hybrid fiber transmission link and support
%%%% QSM with high order MPI crosstalk in the first segement of hybrid span

function [outFieldX,outFieldY,noise] = hybrid_span_v1(fieldX,fieldY,...
    link,symbRate, samplesPerSymbol,Lh,normalizedFreq)
% hybrid_span_v1 takes calibrated signal power into account which excludes
% the transition data sammples generated by transmitter filter)
nSpans = link.fiber1.numberSpans;
if (nSpans <= 0)
    % bypass the filber link
   outFieldX = fieldX;
   outFieldY = fieldY;
   noise = zeros(1,3);
   fprintf('\n Bypass the fiber link\n'); 
   
else
  if (~strcmp(link.fiber1.flag_1,'g-sx'))
      error ('wrong flag.  Currently only support ''g-sx'' /');
  end      
    nSpans = link.fiber1.numberSpans;
    fiberLength_1 = link.fiber1.length_1;
    alphadB_1 = link.fiber1.alphadB_1;
    aeff_1 = link.fiber1.aeff_1;
    n2_1= link.fiber1.n2_1;
    lambda_1 = link.fiber1.lambda_1;
    disp_1 = link.fiber1.disp_1;
    slope_1 = link.fiber1.slope_1;
   
    stepLength_1 = link.fiber1.steplength_1;   % Step length [m]
    dphimax_1 = link.fiber1.dphimax_1;         % Maximum nonlinear phase rotation per step                   
    dzmax_1 = link.fiber1.dzmax_1;             % Maximum SSFM step 

    fiberLength_1 = fiberLength_1*1e3;   % change length unit to [m]
    
    fiberLength_2 = link.fiber1.length_2;
    alphadB_2 = link.fiber1.alphadB_2;
    aeff_2 = link.fiber1.aeff_2;
    n2_2= link.fiber1.n2_2;
    lambda_2 = link.fiber1.lambda_2;
    disp_2 = link.fiber1.disp_2;
    slope_2 = link.fiber1.slope_2;
   
    stepLength_2 = link.fiber1.steplength_2;   % Step length [m]
    dphimax_2 = link.fiber1.dphimax_2;         % Maximum nonlinear phase rotation per step                   
    dzmax_2 = link.fiber1.dzmax_2;             % Maximum SSFM step 

    fiberLength_2 = fiberLength_2*1e3;   % change length unit to [m]
    
    channelWavelength = link.channelWavelengths;
    noise = zeros(1,3);

    fieldAmpX = real(fieldX)+1j*imag(fieldX);
    fieldAmpY = real(fieldY)+1j*imag(fieldY);

    [Nfft,nfc] = size(fieldAmpX);
    Lh2 = (Lh-1)/2 ; % transition samples at the beginning and end of data
    launchPower = getSignalPower_v1(fieldX,fieldY, Lh2);  % total launch power in dBm
        
    Nch = length(channelWavelength);   %  number of channels
        
    launchPowerdBmCh = launchPower - 10*log10(Nch);   %launch power per channel in dBm

 
   for i = 1 : nSpans
%     i
    %[Nfft,nfc] = size(fieldAmpX);
    % fiber span - first segement
    [outFieldFiberX1, outFieldFiberY1] = fiber(fieldAmpX,fieldAmpY,symbRate,fiberLength_1,alphadB_1,...
    aeff_1,n2_1,lambda_1,disp_1,slope_1,channelWavelength,stepLength_1,normalizedFreq,dzmax_1,dphimax_1);
    
    % fiber span - second segment
    [outFieldFiberX, outFieldFiberY] = fiber(outFieldFiberX1,outFieldFiberY1,symbRate,fiberLength_2,alphadB_2,...
    aeff_2,n2_2,lambda_2,disp_2,slope_2,channelWavelength,stepLength_2,normalizedFreq,dzmax_2,dphimax_2);
    
    % pass through a link amplifier
    if (strcmp(link.fiber1.useAmplification,'yes'))
        noiseFigure = link.fiber1.amplifier.noiseFig; 
        totalSpanLossdB = alphadB_1*(fiberLength_1*1e-3)+alphadB_2*(fiberLength_2*1e-3);  % total span loss in dB
        fiberLength = fiberLength_1+fiberLength_2;    % total span length in m
        alphadB = totalSpanLossdB/(fiberLength*1e-3);   % average span attenuation dB/km
      [outFieldAmplifiX,outFieldAmplifiY,noise] = ampliflat(outFieldFiberX,outFieldFiberY,...
        alphadB,fiberLength,symbRate,channelWavelength,noiseFigure,samplesPerSymbol,noise);

        fieldAmpX = outFieldAmplifiX;
        fieldAmpY = outFieldAmplifiY;
    
    else
        fieldAmpX = outFieldFiberX;
        fieldAmpY = outFieldFiberY;
    end
    
   end

 %  The MPI crosstalk is added as AWGN at the end of link.
    if (strcmp(link.fiber1.MPI.useCrosstalk,'yes'))
        rng(i*13);   % change random seeds
        %[Nfft,nfc] = size(fieldAmpX);
        deltaAlpha = link.fiber1.MPI.deltaAlpha;    % Differential attnuation coefficient  [dB/km]   
        deltaAlphaLin = (log(10)*1e-4)*deltaAlpha;   % delta alpha in linear units [m^-1]
       
        % Sigma will be proportional to the percenatage of MPI compensation
        % that we want to apply. If the percentage is 100 sigma will be 0
        % because that indicated that we dont want any MPI effect.
        percComp = link.fiber1.MPI.percComp;
        kappa = link.fiber1.MPI.kappa*1e-3;  % change kappa unit to [m^-1]
        spanMPI = ((deltaAlphaLin*fiberLength_1)-1+exp(-deltaAlphaLin*fiberLength_1))...
            *(kappa^2)/(deltaAlphaLin^2);  
        
        signalPower = getSignalPower_v1(fieldAmpX,fieldAmpY,Lh2);  % total signal power (9 channels) mW    
        %signalPower = sum((abs(fieldAmpX).^2+abs(fieldAmpY).^2))/Nfft;  % total signal power (9 channels) mW
                   
        noisePower = nSpans*spanMPI*signalPower ;   % total MPI noise power at the end of link in mW
        %noisePower = nSpans*spanMPI*launchPower;    % total MPI noise power at the end
       
        MPIvariance =  noisePower*samplesPerSymbol/Nch;
        
        sigma = sqrt(((100-percComp)/100)*MPIvariance/4);  %  sqrt(mW). sigma^2 is the variance
        
        % generate the white additive Gaussian noises to be added the field.
        noiseX = sigma * (randn(Nfft,nfc)+1j*randn(Nfft,nfc));
        noiseY = sigma * (randn(Nfft,nfc)+1j*randn(Nfft,nfc));

        % The MPI crosstalk is added as the AWGN
        fieldAmpX = fieldAmpX + noiseX;
        fieldAmpY = fieldAmpY + noiseY;
        
    end   
   
 %% remove the CD accumulated in fiber 1 
    fiberLength_0 = 1;     % fiberlength in m
    alphadB_0 = 0;
    aeff_0 = aeff_1;
    n2_0= 0;
    lambda_0 = lambda_1;
    totalSpanDisp = (fiberLength_1*disp_1+fiberLength_2*disp_2)*1e-3;  % total span dispersion (ps/nm)
    disp_0 = -nSpans*totalSpanDisp/(fiberLength_0*1e-3) ;   %dispersion ps/nm/km 
    slope_0 = 0;
    stepLength_0 = stepLength_1;
    dzmax_0 = dzmax_1;
    dphimax_0 = dphimax_1;


   [outFieldFiberX, outFieldFiberY] = fiber(fieldAmpX,fieldAmpY,symbRate,fiberLength_0,alphadB_0,...
   aeff_0,n2_0,lambda_0,disp_0,slope_0,channelWavelength,stepLength_0,normalizedFreq,dzmax_0,dphimax_0);
    
   % endoflinkPower = sum(abs(fieldAmpX).^2+abs(fieldAmpY).^2)/Nfft;  % total launch power in mW
   % endofCDcompPower = sum(abs(outFieldFiberX).^2+abs(outFieldFiberY).^2)/Nfft;    
            
   % endoflinkPowerdBmCh = 10*log10(endoflinkPower/Nch);   %launch power per channel in dBm

   % endofCDcompPowerdBmCh = 10*log10(endofCDcompPower/Nch); 

    outFieldX = outFieldFiberX;
    outFieldY = outFieldFiberY;
end


%--------------------------------------------------------------------------
function [outFieldX, outFieldY] = fiber(fieldX,fieldY,symbRate,fiberLength,alphadB,...
    aeff,n2,lambda,disp,slope,channelWavelength,stepLength,normalizedFreq,dzmax,dphimax)

x.length = fiberLength;     % fiber length  [m]
x.alphadB = alphadB;        % attenuation  [dB/km]
x.aeff = aeff;              % effective area  [um^2]
x.n2 = n2;                  % nonlinear index [m^2/W]
x.lambda = lambda;          % wavelength  [nm]
x.disp = disp;              % disperison  [ps/nm/km]
x.slope = slope;            % slope in [ps/nm^2/km]

cLight = 299792458;      % speed of lightin vacuum [m/s]


[Nfft,nfc] = size(fieldX);    % if nfc == 1 there is only one field 


%%%%%%%%%%%%%%%%%%%%%%%%%%%% CONVERSIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

alphalin = (log(10)*1e-4)*x.alphadB;      % [m^-1]

b20 = -x.lambda^2/2/pi/cLight*x.disp*1e-6; % beta2 [ns^2/m] @ lambda
b30 = (x.lambda/2/pi/cLight)^2*(2*x.lambda*x.disp+x.lambda^2*x.slope)*1e-6; % beta3 [ns^3/m] @ lambda                    

maxl = max(channelWavelength);
minl = min(channelWavelength); 
lamc = 2*maxl*minl/(maxl+minl); %central wavelength: 1/lamc = 0.5(1/maxl+1/minl)

% Domega_ik: [1/ns]. "i" -> at ch. i, "0" -> at lambda, "c" -> at lamc
Domega_i0 = 2*pi*cLight*(1./channelWavelength-1/x.lambda);    
Domega_ic = 2*pi*cLight*(1./channelWavelength-1/lamc);    
Domega_c0 = 2*pi*cLight*(1./lamc-1/x.lambda); 
b1 = b20*Domega_ic+0.5*b30*(Domega_i0.^2-Domega_c0.^2);  %ch's beta1 [ns/m]


if nfc == 1
    beta1 = 0;    % [ns/m] @ lamc
    Domega_i0_nfc1 = 2*pi*cLight*(1./lamc-1/x.lambda);        
	gam = 2*pi*x.n2./(lamc*x.aeff)*1e18; % nonlinear index [1/mW/m]
    beta2 = b20+b30*Domega_i0_nfc1;  % beta2 [ns^2/m]@ lamc (nfc=1) or channelWavelength
                            % (nfc ~= 1).
else                                     
    beta1 = b1;   % [ns/m] @ channelWavelength
	gam = 2*pi*x.n2./(channelWavelength*x.aeff)*1e18; % nonlinear index [1/mW/m]
    beta2 = b20+b30*Domega_i0;  % beta2 [ns^2/m]@ lamc (nfc=1) or channelWavelength
                            % (nfc ~= 1).
end


betat = zeros(Nfft,nfc);    % beta, whose Taylor coeffs are the betai
omega = 2*pi*(symbRate*1e-9)*normalizedFreq'; % angular frequency [rad/ns] in column vector
                                            
for kch=1:nfc
    betat(:,kch) = omega*beta1(kch)+0.5*omega.^2*beta2(kch)+...
        omega.^3*b30/6;   % beta coefficient [1/m]
end


[outFieldX,outFieldY]=resolution(fieldX,fieldY,beta2,gam,...
    alphalin,omega,x.length,stepLength,dzmax,dphimax);
% [outFieldX,outFieldY] = agrawalResolution(fieldX,fieldY,b20,gam,...
%     alphalin,omega,x.length,stepLength,dzmax,dphimax); resolutionOptiluxStepCalculation
% [outFieldX,outFieldY]=resolutionOptiluxStepCalculation(fieldX,fieldY,beta2,gam,...
%     alphalin,omega,x.length,stepLength,dzmax,dphimax);



%--------------------------------------------------------------------------
function [outFieldX,outFieldY] = resolution(fieldX,fieldY,beta,gam,...
    alphalin,omega,fiberLength,stepLength,dzmax,dphimax)

gamPrime = 8/9 * gam;
% stepsRecord = zeros(1,200);
% cont = 0;
% steps = fiberLength/stepLength; % For equal size steps

% stepLength = nextstep(dzmax,dphimax,gamPrime,alphalin,fieldX,fieldY);
distance = stepLength;
%     cont = cont + 1;
% stepsRecord(cont) = distance;
while distance < fiberLength

    % Linear step
    [fieldXprime,fieldYprime] = lin_step_vector(fieldX,fieldY,alphalin,beta,omega,stepLength);


    % NL step
%     [fieldXprime2,fieldYprime2] = nl_step_vector(fieldXprime,fieldYprime,gamPrime,stepLength);
    %----------- New Approximation -----------
    [fieldXprime2,fieldYprime2] = nl_step_vector2(fieldXprime,fieldYprime,gamPrime,stepLength,alphalin);
    %----------- New Approximation -----------

    %Linear step again
    [fieldX,fieldY] = lin_step_vector(fieldXprime2,fieldYprime2,alphalin,beta,omega,stepLength);
    

%     % Attenuation step
%     fieldX = fieldX * exp(-(alphalin*stepLength/2));
%     fieldY = fieldY * exp(-(alphalin*stepLength/2));
%     stepLength = nextstep(dzmax,dphimax,gamPrime,alphalin,fieldX,fieldY);
    distance = distance + stepLength;
%     cont = cont + 1;
%     stepsRecord(cont) = distance;

end


lastStep = fiberLength-distance+stepLength; % last step

% Linear step
[fieldXprime,fieldYprime] = lin_step_vector(fieldX,fieldY,alphalin,beta,omega,lastStep);
% NL step
% [fieldXprime2,fieldYprime2] = nl_step_vector(fieldXprime,fieldYprime,gamPrime,lastStep);
%----------- New Approximation -----------
[fieldXprime2,fieldYprime2] = nl_step_vector2(fieldXprime,fieldYprime,gamPrime,lastStep,alphalin);
%----------- New Approximation -----------
%Linear step again
[fieldX,fieldY] = lin_step_vector(fieldXprime2,fieldYprime2,alphalin,beta,omega,lastStep);
% Attenuation step
% fieldX = fieldX * exp(-(alphalin*lastStep/2));
% fieldY = fieldY * exp(-(alphalin*lastStep/2));

outFieldX = fieldX;
outFieldY = fieldY;


%--------------------------------------------------------------------------
function [outFieldX,outFieldY] = resolutionOptiluxStepCalculation(fieldX,fieldY,beta,gam,...
    alphalin,omega,fiberLength,stepLength,dzmax,dphimax)

gamPrime = 8/9 * gam;
stepsRecord = zeros(1,1000);
cont = 0;
% steps = fiberLength/stepLength; % For equal size steps

stepLength = nextstep(dzmax,dphimax,gamPrime,alphalin,fieldX,fieldY);
distance = stepLength;
cont = cont + 1;
stepsRecord(cont) = stepLength;
while distance < fiberLength

    % Linear step
    [fieldXprime,fieldYprime] = lin_step_vector(fieldX,fieldY,alphalin,beta,omega,stepLength);


    % NL step
%     [fieldXprime2,fieldYprime2] = nl_step_vector(fieldXprime,fieldYprime,gamPrime,stepLength);
    %----------- New Approximation -----------
    [fieldXprime2,fieldYprime2] = nl_step_vector2(fieldXprime,fieldYprime,gamPrime,stepLength,alphalin);
    %----------- New Approximation -----------

    %Linear step again
    [fieldX,fieldY] = lin_step_vector(fieldXprime2,fieldYprime2,alphalin,beta,omega,stepLength);
    

%     % Attenuation step
%     fieldX = fieldX * exp(-(alphalin*stepLength/2));
%     fieldY = fieldY * exp(-(alphalin*stepLength/2));
    stepLength = nextstep(dzmax,dphimax,gamPrime,alphalin,fieldX,fieldY);
    distance = distance + stepLength;
    cont = cont + 1;
    stepsRecord(cont) = stepLength;

end


lastStep = fiberLength-distance+stepLength; % last step

% Linear step
[fieldXprime,fieldYprime] = lin_step_vector(fieldX,fieldY,alphalin,beta,omega,lastStep);
% NL step
% [fieldXprime2,fieldYprime2] = nl_step_vector(fieldXprime,fieldYprime,gamPrime,lastStep);
%----------- New Approximation -----------
[fieldXprime2,fieldYprime2] = nl_step_vector2(fieldXprime,fieldYprime,gamPrime,lastStep,alphalin);
%----------- New Approximation -----------
%Linear step again
[fieldX,fieldY] = lin_step_vector(fieldXprime2,fieldYprime2,alphalin,beta,omega,lastStep);
% Attenuation step
% fieldX = fieldX * exp(-(alphalin*lastStep/2));
% fieldY = fieldY * exp(-(alphalin*lastStep/2));

figure(1)
plot(stepsRecord)

outFieldX = fieldX;
outFieldY = fieldY;


%--------------------------------------------------------------------------
function [Exprime,Eyprime] = lin_step_vector(Ex,Ey,alphalin,beta2,omega,h)

% Conversion to the frequency domain
% Field X
g_Ex = gpuArray(Ex);
ExSpectrum = fft(g_Ex);

% ExSpectrum = fftshift(ExSpectrum);
% Field Y
g_Ey = gpuArray(Ey);
EySpectrum = fft(g_Ey);
% EySpectrum = fftshift(EySpectrum);

% Dispersion step
Hf = fastexp(-(beta2*omega.^2/2*h/2)); % Fast exponential: fastexp(x) = exp(ix)
ExSpectrum = ExSpectrum .* Hf;
EySpectrum = EySpectrum .* Hf;

% % Attenuation step
% ExSpectrum = ExSpectrum .* exp(-(alphalin*h/4));
% EySpectrum = EySpectrum .* exp(-(alphalin*h/4));

% Conversion to the time domain again
% Field X
% ExSpectrum = ifftshift(ExSpectrum);
Exprime = ifft(ExSpectrum);
% Field Y
% EySpectrum = ifftshift(EySpectrum);
Eyprime = ifft(EySpectrum);

% Attenuation step
attn = exp(-(alphalin*h/4));
Exprime = gather(Exprime .* attn);
Eyprime = gather(Eyprime .* attn);



%--------------------------------------------------------------------------
function [Exprime2,Eyprime2] = nl_step_vector(Exprime,Eyprime,gamma,h)

% Nonlinear step
Exprime2 = Exprime .* fastexp(-gamma*(abs(Exprime).^2+abs(Eyprime).^2)*h);
Eyprime2 = Eyprime .* fastexp(-gamma*(abs(Exprime).^2+abs(Eyprime).^2)*h);

Exprime2 = Exprime2 .* exp(-(alphalin*h/2));
Eyprime2 = Eyprime2 .* exp(-(alphalin*h/2));


%--------------------------------------------------------------------------
function [Exprime2,Eyprime2] = nl_step_vector2(Exprime,Eyprime,gamma,h,alphalin)

if (alphalin == 0)
    Leff = h;
else
    Leff = (1-exp(-alphalin*h))/alphalin;  % effective length of h
end

% Nonlinear step
nonFactor = fastexp(-gamma*(abs(Exprime).^2+abs(Eyprime).^2)*Leff);
Exprime2 = Exprime .* nonFactor;
Eyprime2 = Eyprime .* nonFactor;

% Exprime2 = Exprime2 .* exp(-(alphalin*h/2));
% Eyprime2 = Eyprime2 .* exp(-(alphalin*h/2));


%--------------------------------------------------------------------------
function [Exprime2,Eyprime2] = nl_step_vector_Agrawal(Exprime,Exo,Eyprime,Eyo,gamma,h,alphalin)

Leff = (1-exp(-alphalin*h))/alphalin;

% Nonlinear step
Exprime2 = Exprime .* fastexp(-gamma*(abs(Exprime).^2+abs(Exo).^2+abs(Eyprime).^2+abs(Eyo).^2)*Leff);
Eyprime2 = Eyprime .* fastexp(-gamma*(abs(Exprime).^2+abs(Exo).^2+abs(Eyprime).^2+abs(Eyo).^2)*Leff);

Exprime2 = Exprime2 .* exp(-(alphalin*h/2));
Eyprime2 = Eyprime2 .* exp(-(alphalin*h/2));


%--------------------------------------------------------------------------
function [outFieldX,outFieldY] = agrawalResolution(fieldX,fieldY,beta,gam,...
    alphalin,omega,fiberLength,stepLength,dzmax,dphimax)

gamPrime = 8/9 * gam;
cont = 0;
% stepsRecord = zeros(1,200);
% steps = fiberLength/stepLength; % For equal size steps

stepLength = nextstep(dzmax,dphimax,gamPrime,alphalin,fieldX,fieldY);
distance = stepLength;
cont = cont + 1;
% stepsRecord(cont) = stepLength;
iterateAgain = true;
% fieldXo = complex(zeros(size(fieldX)));
% fieldYo = complex(zeros(size(fieldX)));
while distance < fiberLength
    
    fieldXo = fieldX;
    fieldYo = fieldY;
    fieldXin = fieldX;
    fieldYin = fieldY;
    while (iterateAgain)
        % Linear step
        [fieldXprime,fieldYprime] = lin_step_vector(fieldXin,fieldYin,alphalin,beta,omega,stepLength);

        % NL step
        [fieldXprime2,fieldYprime2] = nl_step_vector_Agrawal(fieldXprime,fieldXo,fieldYprime,fieldYo,gamPrime,stepLength,alphalin);
        %--------- New Approximation ---------
    %     [fieldXprime2,fieldYprime2] = nl_step_vector2(fieldXprime,fieldYprime,gamPrime,stepLength,alphadB);
        %--------- New Approximation ---------

        % Linear step again
        [fieldX,fieldY] = lin_step_vector(fieldXprime2,fieldYprime2,alphalin,beta,omega,stepLength);
        
        if (round((abs(real(sum(fieldXo)^2)-real(sum(fieldX)^2))*1e-1)) == 0)
            iterateAgain = false;
        end
        
        if (iterateAgain)
            fieldXo = fieldX;
            fieldYo = fieldY;
        end
    end
    % Attenuation step
%     fieldX = fieldX * exp(-(alphalin*stepLength/2));
%     fieldY = fieldY * exp(-(alphalin*stepLength/2));
    stepLength = nextstep(dzmax,dphimax,gamPrime,alphalin,fieldX,fieldY);
    distance = distance + stepLength;
    cont = cont + 1;
%     stepsRecord(cont) = stepLength;
    iterateAgain = true;
end

lastStep = fiberLength-distance+stepLength; % last step

fieldXo = fieldX;
fieldYo = fieldY;
fieldXin = fieldX;
fieldYin = fieldY;
while (iterateAgain)
    % Linear step
    [fieldXprime,fieldYprime] = lin_step_vector(fieldXin,fieldYin,alphalin,beta,omega,stepLength);
    % NL step
    [fieldXprime2,fieldYprime2] = nl_step_vector_Agrawal(fieldXprime,fieldXo,fieldYprime,fieldYo,gamPrime,stepLength,alphalin);
    %--------- New Approximation ---------
%     [fieldXprime2,fieldYprime2] = nl_step_vector2(fieldXprime,fieldYprime,gamPrime,stepLength,alphadB);
    %--------- New Approximation ---------
    % Linear step again
    [fieldX,fieldY] = lin_step_vector(fieldXprime2,fieldYprime2,alphalin,beta,omega,stepLength);
    if (round((abs(real(sum(fieldXo)^2)-real(sum(fieldX)^2))*1e-1)) == 0)
        iterateAgain = false;
    end
    if (iterateAgain)
        fieldXo = fieldX;
        fieldYo = fieldY;
    end
end

outFieldX = fieldX;
outFieldY = fieldY;

%--------------------------------------------------------------------------
function y=fastexp(x)
%FASTEXP Calculates exp( i * x ) quickly
%   Y=FASTEXP(X) 
%   It's a fast computation of the expression:
%       Y = EXP( i * X )
%   If you have compiled the file fastexp.c with mex then Matlab will run
%   the still quicker (or quickest) fastexp.mexglx
%
%   Author: Massimiliano Salsi, 2009
%	Author: Paolo Serena, 2009
%   University of Parma, Italy

%    This file is part of Optilux, the optical simulator toolbox.
%    Copyright (C) 2009  Paolo Serena, <serena@tlc.unipr.it>
%			 
%    Optilux is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 3 of the License, or
%    (at your option) any later version.
%
%    Optilux is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program.  If not, see <http://www.gnu.org/licenses/>.
y=complex(cos(x),sin(x));

%--------------------------------------------------------------------------
function dz_nl=nextstep(dzmax,phimax,gam,alphalin,ux,uy)

%NEXTSTEP step for the SSFM algorithm
%   DZ=NEXTSTEP(DZMAX,PHIMAX,GAM,ALPHALIN,U,NFC,ISV) evaluates the step of  
%   the SSFM algorithm for a fiber having nonlinear gamma coefficient GAM 
%   [1/mW/m] and attenuation ALPHALIN [m^-1]. U is the matrix of electrical
%   fields. NFC is the number of channels (equal to 1 if all channels are 
%   combined into a unique field). ISV=1 if the y component is on.
%   The step corresponds to a maximum nonlinear phase rotation equal to 
%   PHIMAX, under the constraint that it cannot be greater than DZMAX.


Umax = max(real(ux).^2+imag(ux).^2+real(uy).^2+imag(uy).^2); 
   
Pmax = max(gam.*Umax);   % largest gamma*power
leff = phimax/Pmax;             % effective length of the step
dl = alphalin*leff;             % ratio effective length/attenuation length

if dl >= 1
    dz_nl = dzmax;
else
    if alphalin == 0
        step = leff;
    else
        step = -1/alphalin*log(1-dl);
    end
    if step > dzmax
        dz_nl = dzmax;
    else
        dz_nl = step;
    end
end


%--------------------------------------------------------------------------
function [outFieldX,outFieldY,noise] = ampliflat(fieldX,fieldY,...
    alphadB,fiberLength,symbolRate,channelWavelength,noiseFigure,samplesPerSymbol,noise)

%AMPLIFLAT Ideal Optical amplifier with ASE noise.
%   AMPLIFLAT(X,ATYPE) amplifies the optical field. ATYPE is a string     
%   equal to 'gain' if the amplifier has a flat power gain equal to X [dB].
%   Otherwise, ATYPE can be 'fixpower' if the amplifier takes the gain so
%   as to have an output average power for channel ceil(Nch/2) equal 
%   to X [mW], Nch being the number of channels.
%   This options works only with channels separated (see CREATE_FIELD).
%
%   AMPLIFLAT(X,ATYPE,OPTIONS) has the additional variable OPTIONS to
%   insert the amplified spontaneous emission (ASE) noise.
%   OPTIONS is a structure whose fields can be:
%
%   OPTIONS.f:     [dB] is the optical ASE noise figure, which corresponds 
%                  to a one-sided ASE power spectral density, on two 
%                  polarizations, N0 = (F*Gain-1)*h*nu, with Gain the 
%                  amplifier gain, h the Planck's constant and nu the 
%                  channel central frequency. Note: N0= (F*Gain-1)*h*nu is more
%                  accurate for short span than N0=F*(Gain-1)*h*nu.
%                  Hence, ASE power on a frequency band B is Pase = N0*B.
%   OPTIONS.asepol:If it's 'asex' allows to force to zero the ASE noise 
%                  added to fieldY, while for 'asey' allows to force
%                  to zero the noise added to fieldX.
%   OPTIONS.noise: A matrix containing user's defined complex, unit
%                  variance and zero mean Gaussian ASE noise samples. 
%                  OPTIONS.noise must have the same size of 
%                  [fieldX, fieldY] and must be read in that 
%                  way.
%
%   If the amplifier does not generate ASE noise, don't set OPTIONS.
%   
%   Note: AMPLIFLAT assumes the same gain for both polarizations. 
%
%   Author: Paolo Serena, 2009
%   University of Parma, Italy

%    This file is part of Optilux, the optical simulator toolbox.
%    Copyright (C) 2009  Paolo Serena, <serena@tlc.unipr.it>
%			 
%    Optilux is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 3 of the License, or
%    (at your option) any later version.
%
%    Optilux is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program.  If not, see <http://www.gnu.org/licenses/>.

gerbio = alphadB*fiberLength/1e3; % ampli gain [dB]

hPlanck = 6.62606896e-34;      % Planck's constant [J*s]
cLight = 299792458;      % speed of light [m/s]

[nfr,nfc] = size(fieldX);    % if nfc == 1 there is only one field 

gain = 10^(gerbio*0.1);

fieldX = fieldX*sqrt(gain);
fieldY = fieldY*sqrt(gain);

Flin = 10^(noiseFigure*0.1);
if nfc==1
    maxl=max(channelWavelength);
    minl=min(channelWavelength);
    lamc = 2*maxl*minl/(maxl+minl);     % central wavelength
    %sigma = sqrt(1/4*hPlanck*cLight./lamc.*Flin*(gain-1)*...  % added on 3/15/2018
    %samplesPerSymbol.*(symbolRate*1e-9)*1e21);   % sqrt(mW). sigma^2 is the variance
    sigma = sqrt(1/4*hPlanck*cLight./lamc.*(gain*Flin-1)*...
    samplesPerSymbol.*(symbolRate*1e-9)*1e21);   % sqrt(mW). sigma^2 is the variance
else
    %sigma = sqrt(1/4*hPlanck*cLight./channelWavelength.*Flin*(gain-1)*...    % added on 3/15/2018
    %samplesPerSymbol.*(symbolRate*1e-9)*1e21);   % sqrt(mW). sigma^2 is the variance
    sigma = sqrt(1/4*hPlanck*cLight./channelWavelength.*(gain*Flin-1)*...
    samplesPerSymbol.*(symbolRate*1e-9)*1e21);   % sqrt(mW). sigma^2 is the variance
end

noise(1) = noise(1)+sigma;
noise(2) = noise(2)+sigma^2;
sigma_matrix = ones(nfr,1) * sigma;    % size nfr x Nch
noiseX = sigma_matrix .* (randn(nfr,nfc)+1j*randn(nfr,nfc));
noiseY = sigma_matrix .* (randn(nfr,nfc)+1j*randn(nfr,nfc));
noise(3) = noise(3)+((sum(abs(noiseX).^2)+sum(abs(noiseY).^2))./length(noiseX));
outFieldX = fieldX + noiseX;
outFieldY = fieldY + noiseY;
